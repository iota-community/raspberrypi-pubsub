import { Address, Hash, Transfer } from './types';
/**
 * @module validators
 */
/**
 * Checks if input is an `Int8Array` of trit values; `-1, 0, 1`.
 *
 * @method isTrits
 *
 * @param {any} input
 *
 * @return {boolean}
 */
export declare const isTrits: (input: any) => input is Int8Array;
/**
 * Checks if trits are NULL.
 *
 * @method isNullTrits
 *
 * @param {Int8Array} trits
 *
 * @return {boolean}
 */
export declare const isNullTrits: (input: Int8Array) => boolean;
/**
 * Checks if input is correct trytes consisting of [9A-Z]; optionally validate length
 * @method isTrytes
 *
 * @param {string} trytes
 * @param {string | number} [length='1,']
 *
 * @return {boolean}
 */
export declare const isTrytes: (trytes: string, length?: string | number) => trytes is string;
/**
 * @method isTrytesOfExactLength
 *
 * @param {string} trytes
 * @param {number} length
 *
 * @return {boolean}
 */
export declare const isTrytesOfExactLength: (trytes: string, length: number) => boolean;
/**
 * @method isTrytesOfMaxLength
 *
 * @param {string} trytes
 * @param {number} length
 *
 * @return {boolean}
 */
export declare const isTrytesOfMaxLength: (trytes: string, length: number) => boolean;
/**
 * Checks if input contains `9`s only.
 * @method isEmpty
 *
 * @param {string} hash
 *
 * @return {boolean}
 */
export declare const isEmpty: (trytes: any) => trytes is string;
export declare const isNinesTrytes: (trytes: any) => trytes is string;
/**
 * Checks if input is correct hash (81 trytes) or address with checksum (90 trytes)
 *
 * @method isHash
 *
 * @param {string} hash
 *
 * @return {boolean}
 */
export declare const isHash: (hash: any) => hash is string;
export declare const isSecurityLevel: (security: any) => security is number;
/**
 * Checks if input is valid input object. Address can be passed with or without checksum.
 * It does not validate the checksum.
 *
 * @method isInput
 *
 * @param {string} address
 *
 * @return {boolean}
 */
export declare const isInput: (input: any) => input is Address;
/**
 * Checks that input is valid tag trytes.
 *
 * @method isTag
 *
 * @param {string} tag
 *
 * @return {boolean}
 */
export declare const isTag: (tag: any) => tag is string;
/**
 * Checks if input is valid `transfer` object.
 *
 * @method isTransfer
 *
 * @param {Transfer} transfer
 *
 * @return {boolean}
 */
export declare const isTransfer: (transfer: Transfer) => transfer is Transfer;
/**
 * Checks that a given `URI` is valid
 *
 * Valid Examples:
 * - `udp://[2001:db8:a0b:12f0::1]:14265`
 * - `udp://[2001:db8:a0b:12f0::1]`
 * - `udp://8.8.8.8:14265`
 * - `udp://domain.com`
 * - `udp://domain2.com:14265`
 *
 * @method isUri
 *
 * @param {string} uri
 *
 * @return {boolean}
 */
export declare const isUri: (uri: any) => uri is string;
export declare const isStartEndOptions: ({ start, end }: {
    start: number;
    end: number;
}) => boolean;
export declare const isArray: (f: (x: any) => boolean) => (x: ReadonlyArray<any>) => boolean;
export declare type Validatable<T = any> = [T, (x: T) => boolean, string];
export declare type Validator<T> = (x: T, err?: string) => Validatable<T>;
/**
 * Runs each validator in sequence, and throws on the first occurence of invalid data.
 * Validators are passed as arguments and executed in given order.
 * You might want place `validate()` in promise chains before operations that require valid inputs,
 * taking advantage of built-in promise branching.
 *
 * @example
 *
 * ```js
 * try {
 *   validate([
 *     value, // Given value
 *     isTrytes, // Validator function
 *     'Invalid trytes' // Error message
 *   ])
 * } catch (err) {
 *   console.log(err.message) // 'Invalid trytes'
 * }
 * ```
 *
 * @method validate
 *
 * @throws {Error} error
 * @return {boolean}
 */
export declare const validate: (...validators: (false | [any, (x: any) => boolean, string])[]) => boolean;
export declare const arrayValidator: <T>(validator: Validator<T>) => Validator<ReadonlyArray<T>>;
export declare const depthValidator: Validator<number>;
export declare const minWeightMagnitudeValidator: Validator<number>;
export declare const seedValidator: Validator<string>;
export declare const securityLevelValidator: Validator<number>;
export declare const inputValidator: Validator<Address>;
export declare const remainderAddressValidator: Validator<string>;
export declare const tagValidator: Validator<string>;
export declare const transferValidator: Validator<Transfer>;
export declare const hashValidator: Validator<Hash>;
export declare const trytesValidator: (trytes: string, msg?: string | undefined) => (string | ((t: string) => boolean))[];
export declare const uriValidator: Validator<string>;
export declare const integerValidator: Validator<number>;
export declare const indexValidator: Validator<number>;
export declare const startOptionValidator: Validator<number>;
export declare const startEndOptionsValidator: Validator<any>;
export declare const getInputsThresholdValidator: Validator<number>;
export declare const getBalancesThresholdValidator: Validator<number>;
