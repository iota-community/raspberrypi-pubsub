"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var checksum_1 = require("@iota/checksum");
var pad_1 = require("@iota/pad");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var keysOf = function (o) { return Object.keys(o); };
var validKeys = ['bundles', 'addresses', 'tags', 'approvees'];
var hasValidKeys = function (query) {
    for (var _i = 0, _a = keysOf(query); _i < _a.length; _i++) {
        var key = _a[_i];
        if (validKeys.indexOf(key) === -1) {
            throw new Error(errors.INVALID_SEARCH_KEY + ": " + key);
        }
    }
};
exports.validateFindTransactions = function (query) {
    var addresses = query.addresses, approvees = query.approvees, bundles = query.bundles, tags = query.tags;
    hasValidKeys(query);
    guards_1.validate(!!addresses && [addresses, function (arr) { return arr.every(guards_1.isHash); }, errors.INVALID_ADDRESS], !!tags && [tags, function (arr) { return arr.every(guards_1.isTag); }, errors.INVALID_TAG], !!approvees && [
        approvees,
        function (arr) { return arr.every(function (a) { return guards_1.isTrytesOfExactLength(a, transaction_1.TRANSACTION_HASH_LENGTH / signing_1.TRYTE_WIDTH); }); },
        errors.INVALID_TRANSACTION_HASH,
    ], !!bundles && [
        bundles,
        function (arr) { return arr.every(function (b) { return guards_1.isTrytesOfExactLength(b, transaction_1.BUNDLE_LENGTH / signing_1.TRYTE_WIDTH); }); },
        errors.INVALID_HASH,
    ]);
};
exports.removeAddressChecksum = function (query) {
    return query.addresses
        ? __assign({}, query, { addresses: query.addresses.map(checksum_1.removeChecksum) }) : query;
};
exports.padTags = function (query) {
    return query.tags
        ? __assign({}, query, { tags: pad_1.padTagArray(query.tags) }) : query;
};
/**
 * @method createFindTransactions
 *
 * @memberof module:core
 *
 * @param {Provider} provider - Network provider for accessing IRI
 *
 * @return {function} {@link #module_core.findTransactions `findTransactionObjects`}
 */
exports.createFindTransactions = function (_a) {
    var send = _a.send;
    /**
     * Searches for transaction `hashes`  by calling
     * [`findTransactions`](https://docs.iota.org/iri/api#endpoints/findTransactions) command.
     * It allows to search for transactions by passing a `query` object with `addresses`, `tags` and `approvees` fields.
     * Multiple query fields are supported and `findTransactions` returns intersection of results.
     *
     * @example
     *
     * ```js
     * findTransactions({ addresses: ['ADRR...'] })
     *    .then(hashes => {
     *        // ...
     *    })
     *    .catch(err => {
     *        // handle errors here
     *    })
     * ```
     *
     * @method findTransactions
     *
     * @memberof module:core
     *
     * @param {object} query
     * @param {Hash[]} [query.addresses] - List of addresses
     * @param {Hash[]} [query.bundles] - List of bundle hashes
     * @param {Tag[]} [query.tags] - List of tags
     * @param {Hash[]} [query.addresses] - List of approvees
     * @param {Callback} [callback] - Optional callback
     *
     * @returns {Promise}
     * @fulfil {Hash[]} Array of transaction hashes
     * @reject {Error}
     * - `INVALID_SEARCH_KEY`
     * - `INVALID_HASH`: Invalid bundle hash
     * - `INVALID_TRANSACTION_HASH`: Invalid approvee transaction hash
     * - `INVALID_ADDRESS`: Invalid address
     * - `INVALID_TAG`: Invalid tag
     * - Fetch error
     */
    return function findTransactions(query, callback) {
        return Promise.resolve(exports.validateFindTransactions(query))
            .then(function () { return exports.removeAddressChecksum(query); })
            .then(exports.padTags)
            .then(function (formattedQuery) {
            return send(__assign({}, formattedQuery, { command: types_1.IRICommand.FIND_TRANSACTIONS }));
        })
            .then(function (_a) {
            var hashes = _a.hashes;
            return hashes;
        })
            .asCallback(callback);
    };
};
//# sourceMappingURL=createFindTransactions.js.map