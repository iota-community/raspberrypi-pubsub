"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var checksum_1 = require("@iota/checksum");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
/**
 * @method createGetBalances
 *
 * @memberof module:core
 *
 * @param {Provider} provider - Network provider
 *
 * @return {function} {@link #module_core.getBalances `getBalances`}
 */
exports.createGetBalances = function (_a) {
    var send = _a.send;
    /**
     * Fetches _confirmed_ balances of given addresses at the latest solid milestone,
     * by calling [`getBalances`](https://docs.iota.works/iri/api#endpoints/getBalances) command.
     *
     * @example
     * ```js
     * getBalances([address], 100)
     *   .then(({ balances }) => {
     *     // ...
     *   })
     *   .catch(err => {
     *     // ...
     *   })
     * ```
     *
     * @method getBalances
     *
     * @memberof module:core
     *
     * @param {Hash[]} addresses - List of addresses
     * @param {number} threshold - Confirmation threshold, currently `100` should be used
     * @param {Hash[]} [tips] - List of tips to calculate the balance from the PoV of these transactions
     * @param {Callback} [callback] - Optional callback
     *
     * @return {Promise}
     * @fulfil {Balances} Object with list of `balances` and corresponding `milestone`
     * @reject {Error}
     * - `INVALID_HASH`: Invalid address
     * - `INVALID_THRESHOLD`: Invalid `threshold`
     * - Fetch error
     */
    return function (addresses, threshold, tips, callback) {
        // If no tips are provided, switch arguments
        if (tips && typeof tips === 'function') {
            callback = tips;
            tips = [];
        }
        return Promise.resolve(guards_1.validate([addresses, function (arr) { return arr.every(guards_1.isHash); }, errors.INVALID_ADDRESS], guards_1.getBalancesThresholdValidator(threshold), !!tips && [
            tips,
            function (arr) { return arr.every(function (h) { return guards_1.isTrytesOfExactLength(h, transaction_1.TRANSACTION_HASH_LENGTH / signing_1.TRYTE_WIDTH); }); },
            errors.INVALID_TRANSACTION_HASH,
        ]))
            .then(function () {
            return send(__assign({ command: types_1.IRICommand.GET_BALANCES, addresses: addresses.map(checksum_1.removeChecksum), // Addresses passed to IRI should not have the checksum
                threshold: threshold }, (Array.isArray(tips) && tips.length && { tips: tips })));
        })
            .then(function (res) { return (__assign({}, res, { balances: res.balances.map(function (balance) { return parseInt(balance, 10); }) })); })
            .asCallback(callback);
    };
};
//# sourceMappingURL=createGetBalances.js.map