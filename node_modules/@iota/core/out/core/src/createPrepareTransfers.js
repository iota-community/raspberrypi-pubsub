"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var bundle_1 = require("@iota/bundle");
var checksum_1 = require("@iota/checksum");
var converter_1 = require("@iota/converter");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var utils_1 = require("../../utils");
var _1 = require("./");
var hmac_1 = require("./hmac");
var HASH_LENGTH = 81;
var NULL_HASH_TRYTES = '9'.repeat(HASH_LENGTH);
var SECURITY_LEVEL = 2;
var defaults = {
    inputs: [],
    address: undefined,
    remainderAddress: undefined,
    security: 2,
    hmacKey: undefined
};
var isTritArray = function (tritArray, length) {
    return (tritArray instanceof Array || tritArray instanceof Int8Array) &&
        typeof tritArray.every === 'function' &&
        tritArray.every(function (trit) { return [-1, 0, 1].indexOf(trit) > -1; }) &&
        (typeof length === 'number' ? tritArray.length === length : true);
};
exports.getPrepareTransfersOptions = function (options) { return (__assign({}, types_1.getOptionsWithDefaults(defaults)(options), { remainderAddress: options.address || options.remainderAddress || undefined })); };
/**
 * Create a [`prepareTransfers`]{@link #module_core.prepareTransfers} function by passing an optional network `provider`.
 * It is possible to prepare and sign transactions offline, by omitting the provider option.
 *
 * @method createPrepareTransfers
 *
 * @memberof module:core
 *
 * @param {Provider} [provider] - Optional network provider to fetch inputs and remainder address.
 * In case this is omitted, proper input objects and remainder should be passed
 * to [`prepareTransfers`]{@link #module_core.prepareTransfers}, if required.
 *
 * @return {Function} {@link #module_core.prepareTransfers `prepareTransfers`}
 */
exports.createPrepareTransfers = function (provider, now, caller) {
    if (now === void 0) { now = function () { return Date.now(); }; }
    var addInputs = exports.createAddInputs(provider);
    var addRemainder = exports.createAddRemainder(provider);
    /**
     * Prepares the transaction trytes by generating a bundle, filling in transfers and inputs,
     * adding remainder and signing. It can be used to generate and sign bundles either online or offline.
     * For offline usage, please see [`createPrepareTransfers`]{@link #module_core.createPrepareTransfers}
     * which can create a `prepareTransfers` function without a network provider.
     *
     * **Note:** After calling this method, persist the returned transaction trytes in local storage. Only then you should broadcast to network.
     * This will allow for reattachments and prevent key reuse if trytes can't be recovered by querying the network after broadcasting.
     *
     * @method prepareTransfers
     *
     * @memberof module:core
     *
     * @param {string} seed
     *
     * @param {object} transfers
     *
     * @param {object} [options]
     * @param {Input[]} [options.inputs] Inputs used for signing. Needs to have correct security, keyIndex and address value
     * @param {Hash} [options.inputs[].address] Input address trytes
     * @param {number} [options.inputs[].keyIndex] Key index at which address was generated
     * @param {number} [options.inputs[].security] Security level
     * @param {number} [options.inputs[].balance] Balance in iotas
     * @param {Hash} [options.address] Remainder address
     * @param {Number} [options.security = 2] Security level to be used for getting inputs and remainder address
     * @property {Hash} [options.hmacKey] HMAC key used for attaching an HMAC
     *
     * @param {function} [callback] Optional callback
     *
     * @return {Promise}
     * @fulfil {array} Returns bundle trytes
     * @reject {Error}
     * - `INVALID_SEED`
     * - `INVALID_TRANSFER_ARRAY`
     * - `INVALID_INPUT`
     * - `INVALID_REMAINDER_ADDRESS`
     * - `INSUFFICIENT_BALANCE`
     * - `NO_INPUTS`
     * - `SENDING_BACK_TO_INPUTS`
     * - Fetch error, if connected to network
     */
    return function prepareTransfers(seed, transfers, options, callback) {
        if (options === void 0) { options = {}; }
        if (caller !== 'lib') {
            if (options.address) {
                /* tslint:disable-next-line:no-console */
                console.warn('`options.address` is deprecated and will be removed in v2.0.0. Use `options.remainderAddress` instead.');
            }
            if (typeof seed === 'string' ? guards_1.isTrytes(seed) && seed.length < 81 : isTritArray(seed) && seed.length < 243) {
                /* tslint:disable-next-line:no-console */
                console.warn('WARNING: Seeds with less length than 81 trytes are not secure! Use a random, 81-trytes long seed!');
            }
        }
        if (!guards_1.isTrytes(seed) && !isTritArray(seed)) {
            throw new Error(errors.INVALID_SEED);
        }
        var props = Promise.resolve(exports.validatePrepareTransfers(__assign({ transactions: new Int8Array(0), trytes: [], seed: typeof seed === 'string' ? converter_1.trytesToTrits(seed) : new Int8Array(seed), transfers: transfers, timestamp: Math.floor((typeof now === 'function' ? now() : Date.now()) / 1000) }, exports.getPrepareTransfersOptions(options))));
        return utils_1.asyncPipe(exports.addHMACPlaceholder, exports.addTransfers, addInputs, addRemainder, exports.verifyNotSendingToInputs, exports.finalize, exports.addSignatures, exports.addHMAC, exports.asTransactionTrytes)(props)
            .then(function (res) { return res.trytes; })
            .asCallback(callback);
    };
};
exports.validatePrepareTransfers = function (props) {
    var transfers = props.transfers, inputs = props.inputs, security = props.security;
    var remainderAddress = props.address || props.remainderAddress;
    guards_1.validate(guards_1.securityLevelValidator(security), guards_1.arrayValidator(guards_1.transferValidator)(transfers), !!remainderAddress && guards_1.remainderAddressValidator(remainderAddress), inputs.length > 0 && guards_1.arrayValidator(guards_1.inputValidator)(inputs));
    return props;
};
exports.addHMACPlaceholder = function (props) {
    var hmacKey = props.hmacKey, transfers = props.transfers;
    return hmacKey
        ? __assign({}, props, { transfers: transfers.map(function (transfer, i) {
                return transfer.value > 0
                    ? __assign({}, transfer, { message: NULL_HASH_TRYTES + (transfer.message || '') }) : transfer;
            }) }) : props;
};
exports.addTransfers = function (props) {
    var transactions = props.transactions, transfers = props.transfers, timestamp = props.timestamp;
    return __assign({}, props, { transactions: transfers.reduce(function (acc, transfer) {
            var messageTrits = converter_1.trytesToTrits(transfer.message || '');
            var signatureOrMessage = new Int8Array((1 + Math.floor(messageTrits.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH)) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
            signatureOrMessage.set(messageTrits, transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
            return bundle_1.addEntry(acc, {
                signatureOrMessage: signatureOrMessage,
                address: converter_1.trytesToTrits(checksum_1.removeChecksum(transfer.address)),
                value: converter_1.valueToTrits(transfer.value),
                obsoleteTag: converter_1.trytesToTrits(transfer.tag || ''),
                issuanceTimestamp: converter_1.valueToTrits(timestamp),
                tag: converter_1.trytesToTrits(transfer.tag || '')
            });
        }, transactions) });
};
exports.createAddInputs = function (provider) {
    var getInputs = provider ? _1.createGetInputs(provider) : undefined;
    return function (props) {
        var transactions = props.transactions, transfers = props.transfers, inputs = props.inputs, timestamp = props.timestamp, seed = props.seed, security = props.security;
        var threshold = transfers.reduce(function (sum, transfer) { return (sum += transfer.value); }, 0);
        if (threshold === 0) {
            return Promise.resolve(props);
        }
        if (inputs.length && threshold > inputs.reduce(function (acc, input) { return (acc += input.balance); }, 0)) {
            throw new Error(inputs.length ? errors.INSUFFICIENT_BALANCE : errors.NO_INPUTS);
        }
        return (!getInputs || inputs.length
            ? Promise.resolve(inputs)
            : getInputs(converter_1.tritsToTrytes(seed), { security: security, threshold: threshold }).then(function (response) { return response.inputs; })).then(function (res) { return (__assign({}, props, { inputs: res, transactions: res.reduce(function (acc, input) {
                return bundle_1.addEntry(acc, {
                    signatureOrMessage: new Int8Array(input.security * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
                    address: converter_1.trytesToTrits(checksum_1.removeChecksum(input.address)),
                    value: converter_1.valueToTrits(-input.balance),
                    issuanceTimestamp: converter_1.valueToTrits(timestamp)
                });
            }, transactions) })); });
    };
};
exports.createAddRemainder = function (provider) {
    var getNewAddress = provider ? _1.createGetNewAddress(provider, 'lib') : undefined;
    return function (props) {
        var transactions = props.transactions, remainderAddress = props.remainderAddress, seed = props.seed, security = props.security, inputs = props.inputs, timestamp = props.timestamp;
        // Values of transactions in the bundle should sum up to 0.
        var sum = bundle_1.valueSum(transactions, 0, transactions.length);
        // Value > 0 indicates insufficient balance in inputs.
        if (sum > 0) {
            throw new Error(errors.INSUFFICIENT_BALANCE);
        }
        // If value is already zero no remainder is required
        if (sum === 0) {
            return props;
        }
        if (!provider && !remainderAddress) {
            throw new Error(errors.INVALID_REMAINDER_ADDRESS);
        }
        return (remainderAddress
            ? Promise.resolve(remainderAddress)
            : getNewAddress(converter_1.tritsToTrytes(seed), {
                index: exports.getRemainderAddressStartIndex(inputs),
                security: security
            })).then(function (addresses) {
            var addressTrytes = types_1.asArray(addresses)[0];
            return __assign({}, props, { remainderAddress: addressTrytes, transactions: bundle_1.addEntry(transactions, {
                    signatureOrMessage: new Int8Array(transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
                    address: converter_1.trytesToTrits(addressTrytes),
                    value: converter_1.valueToTrits(Math.abs(sum)),
                    issuanceTimestamp: converter_1.valueToTrits(timestamp)
                }) });
        });
    };
};
exports.getRemainderAddressStartIndex = function (inputs) {
    return inputs.slice().sort(function (a, b) { return b.keyIndex - a.keyIndex; })[0].keyIndex + 1;
};
exports.verifyNotSendingToInputs = function (props) {
    var transactions = props.transactions;
    for (var offset = 0; offset < transactions.length; offset += transaction_1.TRANSACTION_LENGTH) {
        if (converter_1.tritsToValue(transaction_1.value(transactions, offset)) < 0) {
            for (var jOffset = 0; jOffset < transactions.length; jOffset += transaction_1.TRANSACTION_LENGTH) {
                if (jOffset !== offset) {
                    if (converter_1.tritsToValue(transaction_1.value(transactions, jOffset)) > 0 &&
                        converter_1.tritsToTrytes(transaction_1.address(transactions, jOffset)) === converter_1.tritsToTrytes(transaction_1.address(transactions, offset))) {
                        throw new Error(errors.SENDING_BACK_TO_INPUTS);
                    }
                }
            }
        }
    }
    return props;
};
exports.finalize = function (props) { return (__assign({}, props, { transactions: bundle_1.finalizeBundle(props.transactions) })); };
exports.addSignatures = function (props) {
    var transactions = props.transactions, inputs = props.inputs, seed = props.seed, nativeGenerateSignatureFunction = props.nativeGenerateSignatureFunction;
    var signatureIndex;
    for (var i = 0; i < transactions.length / transaction_1.TRANSACTION_LENGTH; i++) {
        if (converter_1.tritsToValue(transaction_1.value(transactions, i * transaction_1.TRANSACTION_LENGTH)) < 0) {
            signatureIndex = i;
            break;
        }
    }
    return Promise.all(inputs.map(function (_a) {
        var keyIndex = _a.keyIndex, security = _a.security;
        return signing_1.signatureFragments(seed, keyIndex, security || SECURITY_LEVEL, transaction_1.bundle(transactions), nativeGenerateSignatureFunction);
    })).then(function (signatures) { return (__assign({}, props, { transactions: signatures.reduce(function (acc, signature) {
            var transactionsCopy = bundle_1.addSignatureOrMessage(acc, signature, signatureIndex);
            signatureIndex += signature.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
            return transactionsCopy;
        }, transactions) })); });
};
exports.addHMAC = function (props) {
    var hmacKey = props.hmacKey, transactions = props.transactions;
    return hmacKey ? __assign({}, props, { transactions: hmac_1["default"](transactions, converter_1.trytesToTrits(hmacKey)) }) : props;
};
exports.asTransactionTrytes = function (props) {
    var transactions = props.transactions;
    var trytes = [];
    for (var offset = 0; offset < transactions.length; offset += transaction_1.TRANSACTION_LENGTH) {
        trytes.push(converter_1.tritsToTrytes(transactions.subarray(offset, offset + transaction_1.TRANSACTION_LENGTH)));
    }
    return __assign({}, props, { trytes: trytes.reverse().slice() });
};
//# sourceMappingURL=createPrepareTransfers.js.map