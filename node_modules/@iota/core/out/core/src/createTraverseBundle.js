"use strict";
exports.__esModule = true;
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var transaction_converter_1 = require("@iota/transaction-converter");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var _1 = require("./");
/**
 * @method createTraverseBundle
 *
 * @memberof module:core
 *
 * @param {Provider} provider
 *
 * @return {function} {@link #module_core.traverseBundle `traverseBundle`}
 */
exports.createTraverseBundle = function (provider) {
    var getTrytes = _1.createGetTrytes(provider);
    /**
     * Fetches the bundle of a given the _tail_ transaction hash, by traversing through `trunkTransaction`.
     * It does not validate the bundle.
     *
     * @example
     *
     * ```js
     * traverseBundle(tail)
     *    .then(bundle => {
     *        // ...
     *    })
     *    .catch(err => {
     *        // handle errors
     *    })
     * ```
     *
     * @method traverseBundle
     *
     * @memberof module:core
     *
     * @param {Hash} trunkTransaction - Trunk transaction, should be tail (`currentIndex == 0`)
     * @param {Hash} [bundle=[]] - List of accumulated transactions
     * @param {Callback} [callback] - Optional callback
     *
     * @returns {Promise}
     * @fulfil {Transaction[]} Bundle as array of transaction objects
     * @reject {Error}
     * - `INVALID_TRANSACTION_HASH`
     * - `INVALID_TAIL_HASH`: Provided transaction is not tail (`currentIndex !== 0`)
     * - `INVALID_BUNDLE`: Bundle is syntactically invalid
     * - Fetch error
     */
    return function traverseBundle(trunkTransaction, bundle, callback) {
        if (bundle === void 0) { bundle = []; }
        return Promise.resolve(guards_1.validate([
            trunkTransaction,
            function (t) { return guards_1.isTrytesOfExactLength(t, transaction_1.TRANSACTION_HASH_LENGTH / signing_1.TRYTE_WIDTH); },
            errors.INVALID_TRANSACTION_HASH,
        ]))
            .then(function () { return getTrytes([trunkTransaction]); })
            .then(function (_a) {
            var trytes = _a[0];
            return transaction_converter_1.asTransactionObject(trytes, trunkTransaction);
        })
            .tap(function (transaction) {
            return guards_1.validate(bundle.length === 0 && [transaction, function (t) { return t.currentIndex === 0; }, errors.INVALID_TAIL_TRANSACTION]);
        })
            .then(function (transaction) {
            return transaction.currentIndex === transaction.lastIndex
                ? bundle.concat(transaction)
                : traverseBundle(transaction.trunkTransaction, bundle.concat(transaction));
        })
            .asCallback(arguments[1] === 'function' ? arguments[1] : callback);
    };
};
//# sourceMappingURL=createTraverseBundle.js.map