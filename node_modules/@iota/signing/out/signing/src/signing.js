"use strict";
exports.__esModule = true;
/** @module signing */
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var pad_1 = require("@iota/pad");
var Promise = require("bluebird");
var errors = require("../../errors");
require("../../typed-array");
var add_1 = require("./add");
exports.TRYTE_WIDTH = 3;
exports.MIN_TRYTE_VALUE = -13;
exports.MAX_TRYTE_VALUE = 13;
exports.NUMBER_OF_SECURITY_LEVELS = 3;
exports.HASH_LENGTH = 243;
exports.FRAGMENT_LENGTH = (exports.HASH_LENGTH / exports.NUMBER_OF_SECURITY_LEVELS / exports.TRYTE_WIDTH) * exports.HASH_LENGTH;
exports.NUMBER_OF_FRAGMENT_CHUNKS = exports.FRAGMENT_LENGTH / exports.HASH_LENGTH;
exports.NORMALIZED_FRAGMENT_LENGTH = exports.HASH_LENGTH / exports.TRYTE_WIDTH / exports.NUMBER_OF_SECURITY_LEVELS;
/**
 * @method subseed
 *
 * @param {Int8Array} seed - Seed trits
 * @param {number} index - Private key index
 *
 * @return {Int8Array} subseed trits
 */
function subseed(seed, index) {
    if (!Number.isInteger(index) || index < 0) {
        throw new Error(errors.ILLEGAL_SUBSEED_INDEX);
    }
    var pad = pad_1.padTrits(Math.ceil(seed.length / exports.HASH_LENGTH) * exports.HASH_LENGTH);
    var subseedPreimage = add_1.add(pad(seed), converter_1.fromValue(index));
    var subseedTrits = new Int8Array(exports.HASH_LENGTH);
    var sponge = new kerl_1["default"]();
    sponge.absorb(subseedPreimage, 0, subseedPreimage.length);
    sponge.squeeze(subseedTrits, 0, exports.HASH_LENGTH);
    return subseedTrits;
}
exports.subseed = subseed;
/**
 * @method key
 *
 * @param {Int8Array} subseedTrits - Subseed trits
 * @param {number} numberOfFragments - Number of private key fragments
 *
 * @return {Int8Array} Private key trits
 */
function key(subseedTrits, numberOfFragments) {
    if (subseedTrits.length !== kerl_1["default"].HASH_LENGTH) {
        throw new Error(errors.ILLEGAL_SUBSEED_LENGTH);
    }
    if ([1, 2, 3].indexOf(numberOfFragments) === -1) {
        throw new Error(errors.ILLEGAL_NUMBER_OF_FRAGMENTS);
    }
    var keyTrits = new Int8Array(exports.FRAGMENT_LENGTH * numberOfFragments);
    var sponge = new kerl_1["default"]();
    sponge.absorb(subseedTrits, 0, subseedTrits.length);
    sponge.squeeze(keyTrits, 0, keyTrits.length);
    return keyTrits;
}
exports.key = key;
/**
 * @method digests
 *
 * @param {Int8Array} key - Private key trits
 *
 * @return {Int8Array}
 */
// tslint:disable-next-line no-shadowed-variable
function digests(key) {
    if (key.length === 0 || key.length % exports.FRAGMENT_LENGTH !== 0) {
        throw new Error(errors.ILLEGAL_KEY_LENGTH);
    }
    var numberOfFragments = key.length / exports.FRAGMENT_LENGTH;
    var digestsTrits = new Int8Array(numberOfFragments * exports.HASH_LENGTH);
    var sponge = new kerl_1["default"]();
    for (var i = 0; i < numberOfFragments; i++) {
        var buffer = key.slice(i * exports.FRAGMENT_LENGTH, (i + 1) * exports.FRAGMENT_LENGTH);
        for (var j = 0; j < exports.NUMBER_OF_FRAGMENT_CHUNKS; j++) {
            for (var k = 0; k < exports.MAX_TRYTE_VALUE - exports.MIN_TRYTE_VALUE; k++) {
                sponge.reset();
                sponge.absorb(buffer, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
                sponge.squeeze(buffer, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
            }
        }
        sponge.reset();
        sponge.absorb(buffer, 0, buffer.length);
        sponge.squeeze(digestsTrits, i * exports.HASH_LENGTH, exports.HASH_LENGTH);
    }
    return digestsTrits;
}
exports.digests = digests;
/**
 * @method address
 *
 * @param {Int8Array} digests - Digests trits
 *
 * @return {Int8Array} Address trits
 */
// tslint:disable-next-line no-shadowed-variable
function address(digests) {
    if (digests.length === 0 || digests.length % exports.HASH_LENGTH !== 0) {
        throw new Error(errors.ILLEGAL_DIGESTS_LENGTH);
    }
    var addressTrits = new Int8Array(exports.HASH_LENGTH);
    var sponge = new kerl_1["default"]();
    sponge.absorb(digests.slice(), 0, digests.length);
    sponge.squeeze(addressTrits, 0, exports.HASH_LENGTH);
    return addressTrits;
}
exports.address = address;
/**
 * @method digest
 *
 * @param {array} normalizedBundleFragment - Normalized bundle fragment
 * @param {Int8Array} signatureFragment - Signature fragment trits
 *
 * @return {Int8Array} Digest trits
 */
function digest(normalizedBundleFragment, signatureFragment, // tslint:disable-line
normalizedBundleFragmentOffset, signatureFragmentOffset) {
    if (normalizedBundleFragmentOffset === void 0) { normalizedBundleFragmentOffset = 0; }
    if (signatureFragmentOffset === void 0) { signatureFragmentOffset = 0; }
    if (normalizedBundleFragment.length - normalizedBundleFragmentOffset < exports.NORMALIZED_FRAGMENT_LENGTH) {
        throw new Error(errors.ILLEGAL_NORMALIZED_FRAGMENT_LENGTH);
    }
    if (signatureFragment.length - signatureFragmentOffset < exports.FRAGMENT_LENGTH) {
        throw new Error(errors.ILLEGAL_SIGNATURE_FRAGMENT_LENGTH);
    }
    var buffer = signatureFragment.slice(signatureFragmentOffset, signatureFragmentOffset + exports.FRAGMENT_LENGTH);
    var digestTrits = new Int8Array(exports.HASH_LENGTH);
    var sponge = new kerl_1["default"]();
    for (var j = 0; j < exports.NUMBER_OF_FRAGMENT_CHUNKS; j++) {
        for (var k = normalizedBundleFragment[normalizedBundleFragmentOffset + j] - exports.MIN_TRYTE_VALUE; k-- > 0;) {
            sponge.reset();
            sponge.absorb(buffer, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
            sponge.squeeze(buffer, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
        }
    }
    sponge.reset();
    sponge.absorb(buffer, 0, buffer.length);
    sponge.squeeze(digestTrits, 0, digestTrits.length);
    return digestTrits;
}
exports.digest = digest;
/**
 * @method signatureFragment
 *
 * @param {array} normalizeBundleFragment - normalized bundle fragment
 * @param {keyFragment} keyFragment - key fragment trits
 *
 * @return {Int8Array} Signature Fragment trits
 */
function signatureFragment(normalizedBundleFragment, keyFragment, normalizedBundleFragmentOffset, keyFragmentOffset) {
    if (normalizedBundleFragmentOffset === void 0) { normalizedBundleFragmentOffset = 0; }
    if (keyFragmentOffset === void 0) { keyFragmentOffset = 0; }
    if (normalizedBundleFragment.length - normalizedBundleFragmentOffset < exports.NORMALIZED_FRAGMENT_LENGTH) {
        throw new Error(errors.ILLEGAL_NORMALIZED_FRAGMENT_LENGTH);
    }
    if (keyFragment.length - keyFragmentOffset < exports.FRAGMENT_LENGTH) {
        throw new Error(errors.ILLEGAL_KEY_FRAGMENT_LENGTH);
    }
    var signatureFragmentTrits = keyFragment.slice(keyFragmentOffset, keyFragmentOffset + exports.FRAGMENT_LENGTH);
    var sponge = new kerl_1["default"]();
    for (var j = 0; j < exports.NUMBER_OF_FRAGMENT_CHUNKS; j++) {
        for (var k = 0; k < exports.MAX_TRYTE_VALUE - normalizedBundleFragment[normalizedBundleFragmentOffset + j]; k++) {
            sponge.reset();
            sponge.absorb(signatureFragmentTrits, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
            sponge.squeeze(signatureFragmentTrits, j * exports.HASH_LENGTH, exports.HASH_LENGTH);
        }
    }
    return signatureFragmentTrits;
}
exports.signatureFragment = signatureFragment;
function signatureFragments(seed, index, numberOfFragments, bundle, nativeGenerateSignatureFunction) {
    if (nativeGenerateSignatureFunction && typeof nativeGenerateSignatureFunction === 'function') {
        return nativeGenerateSignatureFunction(Array.prototype.slice.call(seed), index, numberOfFragments, Array.prototype.slice.call(bundle)).then(function (nativeSignature) { return new Int8Array(nativeSignature); });
    }
    var normalizedBundleHash = exports.normalizedBundle(bundle);
    var keyTrits = key(subseed(seed, index), numberOfFragments);
    var signature = new Int8Array(numberOfFragments * exports.FRAGMENT_LENGTH);
    for (var i = 0; i < numberOfFragments; i++) {
        signature.set(signatureFragment(normalizedBundleHash.slice(i * exports.NORMALIZED_FRAGMENT_LENGTH, (i + 1) * exports.NORMALIZED_FRAGMENT_LENGTH), keyTrits.slice(i * exports.FRAGMENT_LENGTH, (i + 1) * exports.FRAGMENT_LENGTH)), i * exports.FRAGMENT_LENGTH);
    }
    return Promise.resolve(signature);
}
exports.signatureFragments = signatureFragments;
/**
 * @method validateSignatures
 *
 * @param {Int8Array} expectedAddress - Expected address trytes
 * @param {Array<Int8Array>} signatureFragments - Array of signatureFragments
 * @param {Int8Array} bundle - Bundle hash
 *
 * @return {boolean}
 */
function validateSignatures(expectedAddress, signatureFragments, // tslint:disable-line
bundle) {
    if (bundle.length !== exports.HASH_LENGTH) {
        throw new Error(errors.ILLEGAL_BUNDLE_HASH_LENGTH);
    }
    var normalizedBundleFragments = [];
    var normalizedBundleHash = exports.normalizedBundle(bundle);
    // Split hash into 3 fragments
    for (var i = 0; i < exports.NUMBER_OF_SECURITY_LEVELS; i++) {
        normalizedBundleFragments[i] = normalizedBundleHash.slice(i * exports.NUMBER_OF_FRAGMENT_CHUNKS, (i + 1) * exports.NUMBER_OF_FRAGMENT_CHUNKS);
    }
    // Get digests
    var digestsTrits = new Int8Array(signatureFragments.length * exports.HASH_LENGTH);
    for (var i = 0; i < signatureFragments.length; i++) {
        var digestBuffer = digest(normalizedBundleFragments[i % exports.NUMBER_OF_SECURITY_LEVELS], signatureFragments[i]);
        for (var j = 0; j < exports.HASH_LENGTH; j++) {
            digestsTrits[i * exports.HASH_LENGTH + j] = digestBuffer[j];
        }
    }
    var actualAddress = address(digestsTrits);
    return expectedAddress.every(function (trit, i) { return trit === actualAddress[i]; });
}
exports.validateSignatures = validateSignatures;
/**
 * Normalizes the bundle hash, with resulting digits summing to zero.
 *
 * @method normalizedBundle
 *
 * @param {Int8Array} bundle - Bundle hash to be normalized
 *
 * @return {Int8Array} Normalized bundle hash
 */
exports.normalizedBundle = function (bundle) {
    if (bundle.length !== exports.HASH_LENGTH) {
        throw new Error(errors.ILLEGAL_BUNDLE_HASH_LENGTH);
    }
    var output = new Int8Array(exports.HASH_LENGTH / exports.TRYTE_WIDTH);
    for (var i = 0; i < exports.NUMBER_OF_SECURITY_LEVELS; i++) {
        var sum = 0;
        for (var j = i * exports.NORMALIZED_FRAGMENT_LENGTH; j < (i + 1) * exports.NORMALIZED_FRAGMENT_LENGTH; j++) {
            sum += output[j] =
                bundle[j * exports.TRYTE_WIDTH] + bundle[j * exports.TRYTE_WIDTH + 1] * 3 + bundle[j * exports.TRYTE_WIDTH + 2] * 9;
        }
        if (sum >= 0) {
            while (sum-- > 0) {
                for (var j = i * exports.NORMALIZED_FRAGMENT_LENGTH; j < (i + 1) * exports.NORMALIZED_FRAGMENT_LENGTH; j++) {
                    if (output[j] > exports.MIN_TRYTE_VALUE) {
                        output[j]--;
                        break;
                    }
                }
            }
        }
        else {
            while (sum++ < 0) {
                for (var j = i * exports.NORMALIZED_FRAGMENT_LENGTH; j < (i + 1) * exports.NORMALIZED_FRAGMENT_LENGTH; j++) {
                    if (output[j] < exports.MAX_TRYTE_VALUE) {
                        output[j]++;
                        break;
                    }
                }
            }
        }
    }
    return output;
};
//# sourceMappingURL=signing.js.map